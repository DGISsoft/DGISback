package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"log"
	"time"

	"github.com/DGISsoft/DGISback/api/auth"
	"github.com/DGISsoft/DGISback/api/graph/model"
	"github.com/DGISsoft/DGISback/env"
	"github.com/DGISsoft/DGISback/middleware"
	"github.com/DGISsoft/DGISback/models"
	"github.com/DGISsoft/DGISback/services/mongo/query"
	dataloader "github.com/graph-gophers/dataloader"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// ================================================================================
// MUTATION RESOLVERS
// ================================================================================

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, err := r.UserService.GetUserByLogin(ctx, input.Login)
	if err != nil {
		log.Printf("Login: Authentication failed for login %s: %v", input.Login, err)
		return nil, fmt.Errorf("invalid credentials")
	}

	if !r.UserService.CheckPassword(user.Password, input.Password) {
		log.Printf("Login: Invalid password provided for user %s", input.Login)
		return nil, fmt.Errorf("invalid credentials")
	}

	jwtManager := auth.NewJWTManager(auth.GetSecretKey(), auth.GetTokenDuration())
	tokenString, err := jwtManager.GenerateToken(user)
	if err != nil {
		log.Printf("Login: Failed to generate token for user %s: %v", user.Login, err)
		return nil, fmt.Errorf("could not generate authentication token")
	}

	authPayload := &model.AuthPayload{
		Token: tokenString,
		User:  user,
	}

	writer, err := middleware.GetResponseWriterFromContext(ctx)
	if err != nil {
		log.Printf("Login: CRITICAL - Could not get ResponseWriter from context: %v", err)
		return nil, fmt.Errorf("internal error (token generated, but could not set cookie)")
	}

	middleware.SignalSetAuthCookieDirect(writer, tokenString)

	return authPayload, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	writer, err := middleware.GetResponseWriterFromContext(ctx)
	if err != nil {
		log.Printf("Logout: Could not get ResponseWriter from context: %v", err)
	} else {
		middleware.SignalClearAuthCookieDirect(writer)
	}

	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*models.User, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized")
	}
	log.Printf("CreateUser: Requested by user ID %s", userClaims.UserID)

	_, err := r.UserService.GetUserByLogin(ctx, input.Login)
	if err == nil {
		return nil, fmt.Errorf("user with login '%s' already exists", input.Login)
	}

	user := &models.User{
		Login:       input.Login,
		Password:    input.Password,
		Role:        models.UserRole(input.Role),
		FullName:    input.FullName,
		Building:    input.Building,
		PhoneNumber: input.PhoneNumber,
		TelegramTag: input.TelegramTag,
		Markers:     []primitive.ObjectID{},
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if !user.Role.IsValid() {
		return nil, fmt.Errorf("invalid user role: %s", input.Role)
	}

	err = r.UserService.CreateUser(ctx, user)
	if err != nil {
		log.Printf("CreateUser: Failed to create user in service: %v", err)
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	if (user.Role == models.UserRoleStarosta || user.Role == models.UserRoleSupervisor || user.Role == models.UserRolePredsedatel) &&
		user.Building != nil && *user.Building != "" {

		if user.ID.IsZero() {
			log.Printf("CreateUser: Warning - User ID is zero after creation, skipping auto-assignment for user login '%s'", user.Login)
		} else {
			log.Printf("CreateUser: Attempting to auto-assign user %s to marker for building '%s'", user.ID.Hex(), *user.Building)

			marker, err := r.MarkerService.GetMarkerByLabel(ctx, *user.Building)
			if err != nil {
				log.Printf("CreateUser: Warning - Could not find marker for building '%s': %v", *user.Building, err)
			} else {
				err = r.MarkerService.AssignUserToMarker(ctx, user.ID, marker.ID)
				if err != nil {
					log.Printf("CreateUser: Warning - Failed to assign user %s to marker %s: %v", user.ID.Hex(), marker.ID.Hex(), err)
				} else {
					log.Printf("CreateUser: Successfully assigned user %s to marker %s for building '%s'", user.ID.Hex(), marker.ID.Hex(), *user.Building)
				}
			}
		}
	}

	user.Password = ""
	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id primitive.ObjectID) (bool, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return false, fmt.Errorf("unauthorized")
	}
	log.Printf("DeleteUser: Requested by user ID %s to delete user ID %s", userClaims.UserID, id.Hex())

	requesterID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return false, fmt.Errorf("invalid requester ID in token")
	}
	if requesterID == id {
		return false, fmt.Errorf("cannot delete yourself")
	}

	userToDelete, err := r.UserService.GetUserByID(ctx, id)
	if err != nil {
		if err.Error() == "user not found" {
			return false, fmt.Errorf("user not found")
		}
		log.Printf("DeleteUser: Failed to get user %s: %v", id.Hex(), err)
		return false, fmt.Errorf("failed to get user: %w", err)
	}

	requester, err := r.UserService.GetUserByID(ctx, requesterID)
	if err != nil {
		log.Printf("DeleteUser: Failed to get requester %s: %v", requesterID.Hex(), err)
		return false, fmt.Errorf("failed to get requester info: %w", err)
	}

	if !requester.HasEqualOrHigherRole(userToDelete.Role) {
		log.Printf("DeleteUser: User %s (role %s) attempted to delete user %s (role %s) - forbidden by role hierarchy",
			requesterID.Hex(), requester.Role, id.Hex(), userToDelete.Role)
		return false, fmt.Errorf("insufficient permissions to delete user with role %s", userToDelete.Role)
	}

	if len(userToDelete.Markers) > 0 {
		log.Printf("DeleteUser: User %s has %d assigned markers, removing...", id.Hex(), len(userToDelete.Markers))
		for _, markerID := range userToDelete.Markers {
			err := r.MarkerService.RemoveUserFromMarker(ctx, id, markerID)
			if err != nil {
				log.Printf("Warning: Failed to remove user %s from marker %s during deletion: %v", id.Hex(), markerID.Hex(), err)
			}
		}
	}

	err = r.UserService.DeleteUser(ctx, id)
	if err != nil {
		log.Printf("DeleteUser: Failed to delete user %s in service: %v", id.Hex(), err)
		return false, fmt.Errorf("failed to delete user: %w", err)
	}

	log.Printf("DeleteUser: Successfully deleted user ID %s", id.Hex())
	return true, nil
}

// AssignUser is the resolver for the assignUser field.
func (r *mutationResolver) AssignUser(ctx context.Context, input model.AssignUserInput) (*models.Marker, error) {
	userID := input.UserID
	markerID := input.MarkerID

	err := r.MarkerService.AssignUserToMarker(ctx, userID, markerID)
	if err != nil {
		log.Printf("AssignUser: Failed to assign user %s to marker %s: %v", userID.Hex(), markerID.Hex(), err)
		return nil, fmt.Errorf("could not assign user to marker: %w", err)
	}

	updatedMarker, err := r.MarkerService.GetMarkerByID(ctx, markerID)
	if err != nil {
		log.Printf("AssignUser: Failed to get updated marker %s: %v", markerID.Hex(), err)
		return nil, fmt.Errorf("failed to fetch updated marker data")
	}

	return updatedMarker, nil
}

// RemoveUser is the resolver for the removeUser field.
func (r *mutationResolver) RemoveUser(ctx context.Context, input model.RemoveUserInput) (*models.Marker, error) {
	userID := input.UserID
	markerID := input.MarkerID

	err := r.MarkerService.RemoveUserFromMarker(ctx, userID, markerID)
	if err != nil {
		log.Printf("RemoveUser: Failed to remove user %s from marker %s: %v", userID.Hex(), markerID.Hex(), err)
		return nil, fmt.Errorf("could not remove user from marker: %w", err)
	}

	updatedMarker, err := r.MarkerService.GetMarkerByID(ctx, markerID)
	if err != nil {
		log.Printf("RemoveUser: Failed to get updated marker %s: %v", markerID.Hex(), err)
		return nil, fmt.Errorf("failed to fetch updated marker data")
	}

	return updatedMarker, nil
}

// SendNotification is the resolver for the sendNotification field.
func (r *mutationResolver) SendNotification(ctx context.Context, input model.SendNotificationInput) (bool, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return false, fmt.Errorf("unauthorized")
	}

	senderID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return false, fmt.Errorf("invalid sender ID in token")
	}

	recipientIDs := input.UserIds

	notifType := models.NotificationTypeGeneral
	if input.Type != nil {
		notifType = models.NotificationType(*input.Type)
	}

	notification := &models.Notification{
		Type:         notifType,
		Title:        input.Title,
		Message:      input.Message,
		SenderID:     senderID,
		RecipientIDs: recipientIDs,
	}

	err = r.NotificationService.CreateNotification(ctx, notification)
	if err != nil {
		log.Printf("SendNotification: Failed to create notification: %v", err)
		return false, fmt.Errorf("could not send notification")
	}

	err = r.NotificationService.CreateUserNotifications(ctx, notification.ID, recipientIDs, senderID)
	if err != nil {
		log.Printf("SendNotification: Failed to create user notifications: %v", err)
		return false, fmt.Errorf("could not deliver notification to all recipients")
	}

	log.Printf("SendNotification: Sent notification '%s' from user %s to %d recipients", input.Title, senderID.Hex(), len(recipientIDs))
	return true, nil
}

// MarkNotificationAsRead is the resolver for the markNotificationAsRead field.
func (r *mutationResolver) MarkNotificationAsRead(ctx context.Context, id primitive.ObjectID) (bool, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return false, fmt.Errorf("unauthorized")
	}

	requesterID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID in token")
	}

	userNotif, err := r.NotificationService.GetUserNotificationByID(ctx, id)
	if err != nil {
		log.Printf("MarkNotificationAsRead: User notification %s not found for user %s: %v", id.Hex(), requesterID.Hex(), err)
		return false, fmt.Errorf("notification not found")
	}

	if userNotif.UserID != requesterID {
		log.Printf("MarkNotificationAsRead: User %s attempted to mark notification %s (owned by %s) as read", requesterID.Hex(), id.Hex(), userNotif.UserID.Hex())
		return false, fmt.Errorf("access denied: you can only mark your own notifications as read")
	}

	if userNotif.Status == models.NotificationStatusRead {
		log.Printf("MarkNotificationAsRead: User notification %s is already marked as read for user %s", id.Hex(), requesterID.Hex())
		return true, nil
	}

	err = r.NotificationService.MarkAsRead(ctx, id)
	if err != nil {
		log.Printf("MarkNotificationAsRead: Failed to mark user notification %s as read for user %s: %v", id.Hex(), requesterID.Hex(), err)
		return false, fmt.Errorf("could not mark notification as read: %w", err)
	}

	log.Printf("MarkNotificationAsRead: Successfully marked user notification %s as read for user %s", id.Hex(), requesterID.Hex())

	redisChannel := fmt.Sprintf("unread_notifications_changed:%s", requesterID.Hex())
	log.Printf("MarkNotificationAsRead: Attempting to publish to Redis channel: %s", redisChannel)

	err = r.RedisService.Publish(ctx, redisChannel, "updated")
	if err != nil {
		log.Printf("MarkNotificationAsRead: Failed to publish to Redis channel %s: %v", redisChannel, err)
	} else {
		log.Printf("MarkNotificationAsRead: Successfully published to Redis channel: %s", redisChannel)
	}

	return true, nil
}

// CreateWeeklyReport is the resolver for the createWeeklyReport field.
func (r *mutationResolver) CreateWeeklyReport(ctx context.Context, input model.CreateWeeklyReportInput) (*models.WeeklyReport, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID in token")
	}

	report := &models.WeeklyReport{
		Applications:          input.Applications,
		Inspection:            input.Inspection,
		Additional:            input.Additional,
		UserID:                userID,
		Status:                models.StatusNotReviewed,
		ApplicationsImageKeys: []string{},
		InspectionImageKeys:   []string{},
		AdditionalImageKeys:   []string{},
	}

	user, err := r.UserService.GetUserByID(ctx, userID)
	if err == nil && user.Role == models.UserRolePredsedatel {
		report.Status = models.StatusReviewed
	}

	createdReport, err := r.ReportService.CreateWeeklyReport(ctx, report)
	if err != nil {
		log.Printf("CreateWeeklyReport: Failed to create report for user %s: %v", userID.Hex(), err)
		return nil, fmt.Errorf("failed to create report: %w", err)
	}

	return createdReport, nil
}

// UploadReportImage is the resolver for the uploadReportImage field.
func (r *mutationResolver) UploadReportImage(ctx context.Context, input model.UploadReportImageInput) (*model.ImageUploadResult, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized")
	}

	fileUpload := input.File

	if fileUpload.File == nil {
		log.Printf("UploadReportImage: Received empty file upload")
		return nil, fmt.Errorf("uploaded file is empty")
	}

	filename := fileUpload.Filename
	contentType := fileUpload.ContentType
	size := fileUpload.Size

	log.Printf("UploadReportImage: Received file: Name=%s, Size=%d bytes, ContentType=%s",
		filename, size, contentType)

	fileContent, err := io.ReadAll(fileUpload.File)
	if err != nil {
		log.Printf("UploadReportImage: Failed to read uploaded file content: %v", err)
		return nil, fmt.Errorf("failed to read file content: %w", err)
	}

	bucket := env.GetEnv("S3_BUCKET", "your-default-bucket")

	uniqueFilename := fmt.Sprintf("%s_%d_%s", userClaims.UserID, time.Now().UnixNano(), filename)

	imageKey, err := r.ReportService.UploadImage(ctx, bucket, fileContent, uniqueFilename, contentType)
	if err != nil {
		log.Printf("UploadReportImage: Failed to upload image for user %s: %v", userClaims.UserID, err)
		return nil, fmt.Errorf("failed to upload image: %w", err)
	}

	log.Printf("UploadReportImage: Successfully uploaded file %s with key %s for user %s",
		filename, imageKey, userClaims.UserID)

	return &model.ImageUploadResult{
		Key:  imageKey,
		Name: uniqueFilename,
	}, nil
}

// AddImagesToReport is the resolver for the addImagesToReport field.
func (r *mutationResolver) AddImagesToReport(ctx context.Context, input model.AddImagesToReportInput) (*models.WeeklyReport, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized")
	}

	report, err := r.ReportService.GetWeeklyReportByID(ctx, input.ReportID)
	if err != nil {
		return nil, fmt.Errorf("report not found")
	}

	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID in token")
	}

	if report.UserID != userID {
		user, err := r.UserService.GetUserByID(ctx, userID)
		if err != nil || (user.Role != models.UserRoleSupervisor && user.Role != models.UserRoleDgis && user.Role != models.UserRolePredsedatel) {
			return nil, fmt.Errorf("access denied")
		}
	}

	appKeys := []string{}
	if input.ApplicationsImageKeys != nil {
		appKeys = input.ApplicationsImageKeys
	}

	inspKeys := []string{}
	if input.InspectionImageKeys != nil {
		inspKeys = input.InspectionImageKeys
	}

	addKeys := []string{}
	if input.AdditionalImageKeys != nil {
		addKeys = input.AdditionalImageKeys
	}

	err = r.ReportService.AddImageKeysToReport(ctx, input.ReportID, appKeys, inspKeys, addKeys)
	if err != nil {
		log.Printf("AddImagesToReport: Failed to add images to report %s: %v", input.ReportID.Hex(), err)
		return nil, fmt.Errorf("failed to add images to report: %w", err)
	}

	updatedReport, err := r.ReportService.GetWeeklyReportByID(ctx, input.ReportID)
	if err != nil {
		return nil, fmt.Errorf("failed to get updated report: %w", err)
	}

	return updatedReport, nil
}

// ================================================================================
// QUERY RESOLVERS
// ================================================================================

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized: valid authentication cookie is required")
	}

	userIDHex := userClaims.UserID
	userObjectID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		log.Printf("Me: Invalid ObjectID format in token for UserID: %s", userIDHex)
		return nil, fmt.Errorf("invalid authentication data")
	}

	user, err := r.UserService.GetUserByID(ctx, userObjectID)
	if err != nil {
		log.Printf("Me: Failed to get user data for ID %s: %v", userIDHex, err)
		return nil, fmt.Errorf("user account unavailable")
	}

	return user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized: valid authentication required")
	}

	log.Printf("Users query: Requested by user ID %s", userClaims.UserID)

	requesterObjectID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		log.Printf("Users query: Invalid ObjectID format in token for UserID: %s", userClaims.UserID)
		return nil, fmt.Errorf("invalid authentication data")
	}

	requester, err := r.UserService.GetUserByID(ctx, requesterObjectID)
	if err != nil {
		log.Printf("Users query: Failed to get requester data for ID %s: %v", userClaims.UserID, err)
		return nil, fmt.Errorf("could not retrieve requester information")
	}

	allUsers, err := r.UserService.GetUsers(ctx)
	if err != nil {
		log.Printf("Users query: Failed to retrieve users from service: %v", err)
		return nil, fmt.Errorf("could not retrieve users list: %w", err)
	}

	var filteredUsers []*models.User
	switch requester.Role {
	case models.UserRoleDgis:
		log.Printf("Users query: DGIS user, returning all %d users", len(allUsers))
		filteredUsers = allUsers
	case models.UserRolePredsedatel, models.UserRoleSupervisor:
		for _, user := range allUsers {
			if user.Role == models.UserRoleStarosta || user.Role == models.UserRoleSupervisor {
				filteredUsers = append(filteredUsers, user)
			}
		}
		log.Printf("Users query: PREDSEDATEL user, returning %d users (STAROSTA and SUPERVISOR only)", len(filteredUsers))
	default:
		log.Printf("Users query: User with role %s attempted to access users list - this should be blocked by schema directives", requester.Role)
		return nil, fmt.Errorf("access denied: insufficient permissions to view users list")
	}

	for _, user := range filteredUsers {
		user.Password = ""
	}

	log.Printf("Users query: Successfully retrieved and filtered %d users for requester %s", len(filteredUsers), userClaims.UserID)
	return filteredUsers, nil
}

// Usersbyid is the resolver for the usersbyid field.
func (r *queryResolver) Usersbyid(ctx context.Context, ids []primitive.ObjectID) ([]*models.User, error) {
	// Проверяем авторизацию пользователя
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized: valid authentication required")
	}

	log.Printf("Usersbyid query: Requested by user ID %s for %d user IDs", userClaims.UserID, len(ids))

	// Если массив ID пуст, возвращаем пустой массив
	if len(ids) == 0 {
		return []*models.User{}, nil
	}

	// Получаем информацию о запрашивающем пользователе
	requesterObjectID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		log.Printf("Usersbyid query: Invalid ObjectID format in token for UserID: %s", userClaims.UserID)
		return nil, fmt.Errorf("invalid authentication data")
	}

	requester, err := r.UserService.GetUserByID(ctx, requesterObjectID)
	if err != nil {
		log.Printf("Usersbyid query: Failed to get requester data for ID %s: %v", userClaims.UserID, err)
		return nil, fmt.Errorf("could not retrieve requester information")
	}

	// Получаем пользователей через даталоадер
	loaders := dataloader.For(ctx)
	keys := make([]string, len(ids))
	for i, id := range ids {
		keys[i] = id.Hex()
	}

	var users []*models.User
	for _, key := range keys {
		thunk := loaders.UserLoader.Load(ctx, dataloader.StringKey(key))
		result, err := thunk()
		if err != nil {
			log.Printf("Usersbyid query: Error loading user %s: %v", key, err)
			continue
		}
		if user, ok := result.(*models.User); ok {
			users = append(users, user)
		}
	}

	// Фильтруем результаты в зависимости от роли запрашивающего пользователя
	var filteredUsers []*models.User
	switch requester.Role {
	case models.UserRoleDgis:
		log.Printf("Usersbyid query: DGIS user, returning all %d requested users", len(users))
		filteredUsers = users
	case models.UserRolePredsedatel:
		for _, user := range users {
			if user.Role == models.UserRoleStarosta || user.Role == models.UserRoleSupervisor {
				filteredUsers = append(filteredUsers, user)
			}
		}
		log.Printf("Usersbyid query: PREDSEDATEL user, returning %d users (STAROSTA and SUPERVISOR only)", len(filteredUsers))
	default:
		log.Printf("Usersbyid query: User with role %s attempted to access users list - filtering applied", requester.Role)
		// Для других ролей возвращаем только пользователей с соответствующими правами
		for _, user := range users {
			if user.Role == models.UserRoleStarosta {
				filteredUsers = append(filteredUsers, user)
			}
		}
	}

	// Убираем пароли из ответа для безопасности
	for _, user := range filteredUsers {
		user.Password = ""
	}

	log.Printf("Usersbyid query: Successfully retrieved and filtered %d users for requester %s", len(filteredUsers), userClaims.UserID)
	return filteredUsers, nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) ([]*models.Marker, error) {
	log.Println("Dashboard resolver called")

	markers, err := r.MarkerService.GetAllMarkersWithUsers(ctx)
	if err != nil {
		log.Printf("Dashboard: Failed to retrieve all markers with users from DB: %v", err)
		return nil, fmt.Errorf("could not load dashboard data")
	}

	log.Printf("Dashboard: Successfully retrieved %d markers from service", len(markers))

	if len(markers) > 0 {
		firstMarker := markers[0]
		log.Printf("Dashboard: First marker ID: %s, Label: %s", firstMarker.ID.Hex(), firstMarker.Label)
		log.Printf("Dashboard: First marker Users field length: %d", len(firstMarker.Users))
		if len(firstMarker.Users) > 0 {
			firstUser := firstMarker.Users[0]
			if firstUser != nil {
				log.Printf("Dashboard: First marker's first user ID: %s, Name: %s", firstUser.ID.Hex(), firstUser.FullName)
			} else {
				log.Println("Dashboard: WARNING: First marker's first user is NIL")
			}
		} else {
			log.Println("Dashboard: First marker has NO users")
		}
	}

	return markers, nil
}

// MyNotifications is the resolver for the myNotifications field.
func (r *queryResolver) MyNotifications(ctx context.Context, statuses []models.NotificationStatus, limit *int, offset *int) ([]*models.UserNotification, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID in token")
	}

	limitVal := 20
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil && *offset > 0 {
		offsetVal = *offset
	}

	var modelStatuses []models.NotificationStatus
	for _, status := range statuses {
		modelStatuses = append(modelStatuses, models.NotificationStatus(status))
	}

	userNotifs, err := r.NotificationService.GetUserNotifications(ctx, userID, modelStatuses, limitVal, offsetVal)
	if err != nil {
		log.Printf("MyNotifications: Failed to get notifications for user %s: %v", userID.Hex(), err)
		return nil, fmt.Errorf("could not retrieve notifications")
	}

	log.Printf("MyNotifications: Retrieved %d notifications for user %s", len(userNotifs), userID.Hex())
	return userNotifs, nil
}

// UnreadNotificationsCount is the resolver for the unreadNotificationsCount field.
func (r *queryResolver) UnreadNotificationsCount(ctx context.Context) (int, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return 0, fmt.Errorf("unauthorized")
	}

	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return 0, fmt.Errorf("invalid user ID in token")
	}

	count, err := r.NotificationService.GetUnreadCount(ctx, userID)
	if err != nil {
		log.Printf("UnreadNotificationsCount: Failed to count for user %s: %v", userID.Hex(), err)
		return 0, fmt.Errorf("could not count notifications")
	}

	return count, nil
}

// GetWeeklyReports is the resolver for the getWeeklyReports field.
func (r *queryResolver) GetWeeklyReports(ctx context.Context) ([]*models.WeeklyReport, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized: valid authentication required")
	}

	requesterObjectID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		log.Printf("GetWeeklyReports: Invalid ObjectID format in token for UserID: %s", userClaims.UserID)
		return nil, fmt.Errorf("invalid authentication data")
	}

	requester, err := r.UserService.GetUserByID(ctx, requesterObjectID)
	if err != nil {
		log.Printf("GetWeeklyReports: Failed to get requester data for ID %s: %v", userClaims.UserID, err)
		return nil, fmt.Errorf("could not retrieve requester information")
	}

	var filter bson.M
	switch requester.Role {
	case models.UserRolePredsedatel:
		filter = bson.M{}
		log.Printf("GetWeeklyReports: Predsedatel %s requesting all reports", requester.ID.Hex())
	case models.UserRoleDgis, models.UserRoleSupervisor:
		predsedatelFilter := bson.M{"role": models.UserRolePredsedatel}
		predsedateli, err := r.UserService.FindUsers(ctx, predsedatelFilter)
		if err != nil {
			log.Printf("GetWeeklyReports: Failed to find Predsedateli for filtering: %v", err)
			excludeUserIDs := make([]primitive.ObjectID, 0, len(predsedateli))
			for _, p := range predsedateli {
				excludeUserIDs = append(excludeUserIDs, p.ID)
			}

			if len(excludeUserIDs) > 0 {
				filter = bson.M{"userID": bson.M{"$nin": excludeUserIDs}}
			} else {
				filter = bson.M{}
			}
			log.Printf("GetWeeklyReports: Non-Predsedatel %s (%s) requesting reports, excluding %d Predsedatel user IDs", requester.Login, requester.Role, len(excludeUserIDs))
		} else {
			log.Printf("GetWeeklyReports: Could not fetch Predsedateli for filtering, returning all reports. Error: %v", err)
			filter = bson.M{}
		}
	default:
		log.Printf("GetWeeklyReports: User %s (%s) attempted to access, denying access", requester.Login, requester.Role)
		return []*models.WeeklyReport{}, nil
	}

	var reports []*models.WeeklyReport

	err = query.FindMany(ctx, r.ReportService.GetCollection(), filter, &reports)
	if err != nil {
		log.Printf("GetWeeklyReports: Failed to retrieve reports with filter %+v: %v", filter, err)
		return nil, fmt.Errorf("could not load weekly reports: %w", err)
	}

	log.Printf("GetWeeklyReports: Successfully retrieved %d reports for user %s (%s)", len(reports), requester.Login, requester.Role)
	return reports, nil
}

// GetReportImages is the resolver for the getReportImages field.
func (r *queryResolver) GetReportImages(ctx context.Context, key []string) ([]*model.ImageData, error) {
	if len(key) == 0 {
		return []*model.ImageData{}, nil
	}

	bucket := env.GetEnv("S3_BUCKET", "your-default-bucket")

	var images []*model.ImageData

	for _, k := range key {
		content, err := r.ReportService.GetImage(ctx, bucket, k)
		if err != nil {
			log.Printf("GetReportImages: Failed to get image %s: %v", k, err)
			// Продолжаем обработку остальных изображений даже если одно не удалось получить
			continue
		}

		encoded := base64.StdEncoding.EncodeToString(content)

		images = append(images, &model.ImageData{
			Key:  k,
			Data: encoded,
			Size: len(content),
		})
	}

	log.Printf("GetReportImages: Successfully retrieved %d out of %d requested images", len(images), len(key))
	return images, nil
}

// ================================================================================
// SUBSCRIPTION RESOLVERS
// ================================================================================

// UnreadNotificationsCountChanged is the resolver for the unreadNotificationsCountChanged field.
func (r *subscriptionResolver) UnreadNotificationsCountChanged(ctx context.Context) (<-chan int, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		log.Println("UnreadNotificationsCountChanged: User NOT authenticated")
		return nil, fmt.Errorf("unauthorized: valid authentication cookie is required for subscription")
	}
	log.Printf("UnreadNotificationsCountChanged: User authenticated, ID: %s", userClaims.UserID)

	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		log.Printf("UnreadNotificationsCountChanged: Invalid user ID format: %s, error: %v", userClaims.UserID, err)
		return nil, fmt.Errorf("invalid user ID in authentication token")
	}

	notificationsChannel := make(chan int, 1)

	redisChannel := fmt.Sprintf("unread_notifications_changed:%s", userID.Hex())
	log.Printf("UnreadNotificationsCountChanged: User %s subscribing to Redis channel: %s", userID.Hex(), redisChannel)

	pubsub := r.RedisService.Subscribe(ctx, redisChannel)

	go func() {
		defer close(notificationsChannel)
		defer func() {
			if pubsub != nil {
				err := pubsub.Close()
				if err != nil {
					log.Printf("UnreadNotificationsCountChanged: Error closing Redis subscription for user %s on channel %s: %v", userID.Hex(), redisChannel, err)
				} else {
					log.Printf("UnreadNotificationsCountChanged: Closed Redis subscription for user %s on channel %s", userID.Hex(), redisChannel)
				}
			}
		}()

		initialCount, err := r.NotificationService.GetUnreadCount(ctx, userID)
		if err != nil {
			log.Printf("UnreadNotificationsCountChanged: Failed to get initial unread count for user %s: %v", userID.Hex(), err)
			initialCount = 0
		}

		log.Printf("UnreadNotificationsCountChanged: Sending initial unread count %d to user %s", initialCount, userID.Hex())

		select {
		case notificationsChannel <- initialCount:
			log.Printf("UnreadNotificationsCountChanged: Sent initial unread count %d to user %s", initialCount, userID.Hex())
		case <-ctx.Done():
			log.Printf("UnreadNotificationsCountChanged: Client disconnected before initial count sent for user %s", userID.Hex())
			return
		}

		redisMsgChannel := pubsub.Channel()
		log.Printf("UnreadNotificationsCountChanged: Listening for messages on Redis channel for user %s", userID.Hex())
		for {
			select {
			case <-ctx.Done():
				log.Printf("UnreadNotificationsCountChanged: Context cancelled, unsubscribing user %s from Redis channel %s", userID.Hex(), redisChannel)
				return
			case msg, ok := <-redisMsgChannel:
				if !ok {
					log.Printf("UnreadNotificationsCountChanged: Redis message channel closed for user %s", userID.Hex())
					return
				}
				if msg != nil {
					log.Printf("UnreadNotificationsCountChanged: Received message on Redis channel for user %s: Channel=%s, Payload=%s", userID.Hex(), msg.Channel, msg.Payload)

					currentCount, err := r.NotificationService.GetUnreadCount(ctx, userID)
					if err != nil {
						log.Printf("UnreadNotificationsCountChanged: Failed to get unread count for user %s after Redis message: %v", userID.Hex(), err)
						continue
					}

					log.Printf("UnreadNotificationsCountChanged: Sending updated unread count %d to user %s", currentCount, userID.Hex())

					select {
					case notificationsChannel <- currentCount:
						log.Printf("UnreadNotificationsCountChanged: Sent updated unread count %d to user %s", currentCount, userID.Hex())
					case <-ctx.Done():
						log.Printf("UnreadNotificationsCountChanged: Client disconnected while sending update to user %s", userID.Hex())
						return
					}
				} else {
					log.Printf("UnreadNotificationsCountChanged: Received nil message on Redis channel for user %s", userID.Hex())
				}
			}
		}
	}()

	return notificationsChannel, nil
}

// ================================================================================
// TYPE RESOLVERS
// ================================================================================

// Sender is the resolver for the sender field.
func (r *notificationResolver) Sender(ctx context.Context, obj *models.Notification) (*model.NotificationSender, error) {
	// Используем даталоадер для загрузки отправителя
	loaders := dataloader.For(ctx)
	thunk := loaders.UserLoader.Load(ctx, dataloader.StringKey(obj.SenderID.Hex()))
	result, err := thunk()
	if err != nil {
		return nil, fmt.Errorf("failed to get sender user: %w", err)
	}

	user, ok := result.(*models.User)
	if !ok {
		return nil, fmt.Errorf("unexpected result type")
	}

	sender := &model.NotificationSender{
		ID:       user.ID,
		FullName: user.FullName,
		Building: user.Building,
	}

	return sender, nil
}

// Markers is the resolver for the markers field.
func (r *userResolver) Markers(ctx context.Context, obj *models.User) ([]*models.Marker, error) {
	if len(obj.Markers) == 0 {
		return []*models.Marker{}, nil
	}

	// Используем даталоадер для загрузки маркеров
	loaders := dataloader.For(ctx)
	var markers []*models.Marker
	for _, markerID := range obj.Markers {
		thunk := loaders.MarkerLoader.Load(ctx, dataloader.StringKey(markerID.Hex()))
		result, err := thunk()
		if err != nil {
			log.Printf("userResolver.Markers: Error loading marker %s: %v", markerID.Hex(), err)
			continue
		}
		if marker, ok := result.(*models.Marker); ok {
			markers = append(markers, marker)
		}
	}

	return markers, nil
}

// Notification is the resolver for the notification field.
func (r *userNotificationResolver) Notification(ctx context.Context, obj *models.UserNotification) (*models.Notification, error) {
	// Используем даталоадер для загрузки уведомления
	loaders := dataloader.For(ctx)
	thunk := loaders.NotificationLoader.Load(ctx, dataloader.StringKey(obj.NotificationID.Hex()))
	result, err := thunk()
	if err != nil {
		log.Printf("userNotificationResolver.Notification: Failed to get notification %s: %v", obj.NotificationID.Hex(), err)
		return nil, fmt.Errorf("failed to load notification details: %w", err)
	}

	notification, ok := result.(*models.Notification)
	if !ok {
		return nil, fmt.Errorf("unexpected result type")
	}

	return notification, nil
}

// Reports is the resolver for the reports field.
func (r *userResolver) Reports(ctx context.Context, obj *models.User) ([]*models.WeeklyReport, error) {
	// Используем даталоадер для загрузки отчетов пользователя
	loaders := dataloader.For(ctx)
	thunk := loaders.ReportLoader.Load(ctx, dataloader.StringKey(obj.ID.Hex()))
	result, err := thunk()
	if err != nil {
		return nil, fmt.Errorf("failed to load reports: %w", err)
	}

	reports, ok := result.([]*models.WeeklyReport)
	if !ok {
		return nil, fmt.Errorf("unexpected result type")
	}

	return reports, nil
}

// ================================================================================
// RESOLVER INTERFACE IMPLEMENTATIONS
// ================================================================================

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Notification returns NotificationResolver implementation.
func (r *Resolver) Notification() NotificationResolver { return &notificationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// UserNotification returns UserNotificationResolver implementation.
func (r *Resolver) UserNotification() UserNotificationResolver { return &userNotificationResolver{r} }

// ================================================================================
// RESOLVER STRUCTS
// ================================================================================

type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type userNotificationResolver struct{ *Resolver }