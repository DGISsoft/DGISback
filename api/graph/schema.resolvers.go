package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/DGISsoft/DGISback/api/auth"
	"github.com/DGISsoft/DGISback/api/graph/model"
	"github.com/DGISsoft/DGISback/middleware"
	"github.com/DGISsoft/DGISback/models"
	"github.com/DGISsoft/DGISback/services/mongo/query"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, err := r.UserService.GetUserByLogin(ctx, input.Login)
	if err != nil {
		log.Printf("Login: Authentication failed for login %s: %v", input.Login, err)
		return nil, fmt.Errorf("invalid credentials")
	}

	if !r.UserService.CheckPassword(user.Password, input.Password) {
		log.Printf("Login: Invalid password provided for user %s", input.Login)
		return nil, fmt.Errorf("invalid credentials")
	}

	jwtManager := auth.NewJWTManager(auth.GetSecretKey(), auth.GetTokenDuration())
	tokenString, err := jwtManager.GenerateToken(user)
	if err != nil {
		log.Printf("Login: Failed to generate token for user %s: %v", user.Login, err)
		return nil, fmt.Errorf("could not generate authentication token")
	}

	authPayload := &model.AuthPayload{
		Token: tokenString,
		User:  user,
	}

	writer, err := middleware.GetResponseWriterFromContext(ctx)
	if err != nil {
		log.Printf("Login: CRITICAL - Could not get ResponseWriter from context: %v", err)
		return nil, fmt.Errorf("internal error (token generated, but could not set cookie)")
	}

	middleware.SignalSetAuthCookieDirect(writer, tokenString)

	return authPayload, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	writer, err := middleware.GetResponseWriterFromContext(ctx)
	if err != nil {
		log.Printf("Logout: Could not get ResponseWriter from context: %v", err)
	} else {
		middleware.SignalClearAuthCookieDirect(writer)
	}

	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*models.User, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized")
	}
	log.Printf("CreateUser: Requested by user ID %s", userClaims.UserID)

	_, err := r.UserService.GetUserByLogin(ctx, input.Login)
	if err == nil {
		return nil, fmt.Errorf("user with login '%s' already exists", input.Login)
	}

	user := &models.User{
		Login:       input.Login,
		Password:    input.Password,
		Role:        models.UserRole(input.Role),
		FullName:    input.FullName,
		Building:    input.Building,
		PhoneNumber: input.PhoneNumber,
		TelegramTag: input.TelegramTag,
		Markers:     []primitive.ObjectID{},
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if !user.Role.IsValid() {
		return nil, fmt.Errorf("invalid user role: %s", input.Role)
	}

	err = r.UserService.CreateUser(ctx, user)
	if err != nil {
		log.Printf("CreateUser: Failed to create user in service: %v", err)
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	if (user.Role == models.UserRoleStarosta || user.Role == models.UserRoleSupervisor || user.Role == models.UserRolePredsedatel) &&
		user.Building != nil && *user.Building != "" {

		if user.ID.IsZero() {
			log.Printf("CreateUser: Warning - User ID is zero after creation, skipping auto-assignment for user login '%s'", user.Login)
		} else {
			log.Printf("CreateUser: Attempting to auto-assign user %s to marker for building '%s'", user.ID.Hex(), *user.Building)

			marker, err := r.MarkerService.GetMarkerByLabel(ctx, *user.Building)
			if err != nil {
				log.Printf("CreateUser: Warning - Could not find marker for building '%s': %v", *user.Building, err)
			} else {
				err = r.MarkerService.AssignUserToMarker(ctx, user.ID, marker.ID)
				if err != nil {
					log.Printf("CreateUser: Warning - Failed to assign user %s to marker %s: %v", user.ID.Hex(), marker.ID.Hex(), err)
				} else {
					log.Printf("CreateUser: Successfully assigned user %s to marker %s for building '%s'", user.ID.Hex(), marker.ID.Hex(), *user.Building)
				}
			}
		}
	}

	user.Password = ""
	return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id primitive.ObjectID) (bool, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return false, fmt.Errorf("unauthorized")
	}
	log.Printf("DeleteUser: Requested by user ID %s to delete user ID %s", userClaims.UserID, id.Hex())

	requesterID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return false, fmt.Errorf("invalid requester ID in token")
	}
	if requesterID == id {
		return false, fmt.Errorf("cannot delete yourself")
	}

	userToDelete, err := r.UserService.GetUserByID(ctx, id)
	if err != nil {
		if err.Error() == "user not found" {
			return false, fmt.Errorf("user not found")
		}
		log.Printf("DeleteUser: Failed to get user %s: %v", id.Hex(), err)
		return false, fmt.Errorf("failed to get user: %w", err)
	}

	requester, err := r.UserService.GetUserByID(ctx, requesterID)
	if err != nil {
		log.Printf("DeleteUser: Failed to get requester %s: %v", requesterID.Hex(), err)
		return false, fmt.Errorf("failed to get requester info: %w", err)
	}

	if !requester.HasEqualOrHigherRole(userToDelete.Role) {
		log.Printf("DeleteUser: User %s (role %s) attempted to delete user %s (role %s) - forbidden by role hierarchy",
			requesterID.Hex(), requester.Role, id.Hex(), userToDelete.Role)
		return false, fmt.Errorf("insufficient permissions to delete user with role %s", userToDelete.Role)
	}

	if len(userToDelete.Markers) > 0 {
		log.Printf("DeleteUser: User %s has %d assigned markers, removing...", id.Hex(), len(userToDelete.Markers))
		for _, markerID := range userToDelete.Markers {
			err := r.MarkerService.RemoveUserFromMarker(ctx, id, markerID)
			if err != nil {
				log.Printf("Warning: Failed to remove user %s from marker %s during deletion: %v", id.Hex(), markerID.Hex(), err)
			}
		}
	}

	err = r.UserService.DeleteUser(ctx, id)
	if err != nil {
		log.Printf("DeleteUser: Failed to delete user %s in service: %v", id.Hex(), err)
		return false, fmt.Errorf("failed to delete user: %w", err)
	}

	log.Printf("DeleteUser: Successfully deleted user ID %s", id.Hex())
	return true, nil
}

// AssignUser is the resolver for the assignUser field.
func (r *mutationResolver) AssignUser(ctx context.Context, input model.AssignUserInput) (*models.Marker, error) {
	userID := input.UserID
	markerID := input.MarkerID

	err := r.MarkerService.AssignUserToMarker(ctx, userID, markerID)
	if err != nil {
		log.Printf("AssignUser: Failed to assign user %s to marker %s: %v", userID.Hex(), markerID.Hex(), err)
		return nil, fmt.Errorf("could not assign user to marker: %w", err)
	}

	updatedMarker, err := r.MarkerService.GetMarkerByID(ctx, markerID)
	if err != nil {
		log.Printf("AssignUser: Failed to get updated marker %s: %v", markerID.Hex(), err)
		return nil, fmt.Errorf("failed to fetch updated marker data")
	}

	return updatedMarker, nil
}

// RemoveUser is the resolver for the removeUser field.
func (r *mutationResolver) RemoveUser(ctx context.Context, input model.RemoveUserInput) (*models.Marker, error) {
	userID := input.UserID
	markerID := input.MarkerID

	err := r.MarkerService.RemoveUserFromMarker(ctx, userID, markerID)
	if err != nil {
		log.Printf("RemoveUser: Failed to remove user %s from marker %s: %v", userID.Hex(), markerID.Hex(), err)
		return nil, fmt.Errorf("could not remove user from marker: %w", err)
	}

	updatedMarker, err := r.MarkerService.GetMarkerByID(ctx, markerID)
	if err != nil {
		log.Printf("RemoveUser: Failed to get updated marker %s: %v", markerID.Hex(), err)
		return nil, fmt.Errorf("failed to fetch updated marker data")
	}

	return updatedMarker, nil
}

// SendNotification is the resolver for the sendNotification field.
func (r *mutationResolver) SendNotification(ctx context.Context, input model.SendNotificationInput) (bool, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return false, fmt.Errorf("unauthorized")
	}

	senderID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return false, fmt.Errorf("invalid sender ID in token")
	}

	// input.UserIds уже []primitive.ObjectID, преобразование не нужно
	recipientIDs := input.UserIds

	// 1. Создать шаблон уведомления
	notifType := models.NotificationTypeGeneral
	if input.Type != nil {
		notifType = models.NotificationType(*input.Type)
	}

	notification := &models.Notification{
		Type:         notifType,
		Title:        input.Title,
		Message:      input.Message,
		SenderID:     senderID,
		RecipientIDs: recipientIDs,
	}

	err = r.NotificationService.CreateNotification(ctx, notification)
	if err != nil {
		log.Printf("SendNotification: Failed to create notification: %v", err)
		return false, fmt.Errorf("could not send notification")
	}

	err = r.NotificationService.CreateUserNotifications(ctx, notification.ID, recipientIDs, senderID)
	if err != nil {
		log.Printf("SendNotification: Failed to create user notifications: %v", err)
		return false, fmt.Errorf("could not deliver notification to all recipients")
	}

	log.Printf("SendNotification: Sent notification '%s' from user %s to %d recipients", input.Title, senderID.Hex(), len(recipientIDs))
	return true, nil
}

// MarkNotificationAsRead is the resolver for the markNotificationAsRead field.
func (r *mutationResolver) MarkNotificationAsRead(ctx context.Context, id primitive.ObjectID) (bool, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return false, fmt.Errorf("unauthorized")
	}

	requesterID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID in token")
	}

	userNotif, err := r.NotificationService.GetUserNotificationByID(ctx, id)
	if err != nil {
		log.Printf("MarkNotificationAsRead: User notification %s not found for user %s: %v", id.Hex(), requesterID.Hex(), err)
		return false, fmt.Errorf("notification not found")
	}

	if userNotif.UserID != requesterID {
		log.Printf("MarkNotificationAsRead: User %s attempted to mark notification %s (owned by %s) as read", requesterID.Hex(), id.Hex(), userNotif.UserID.Hex())
		return false, fmt.Errorf("access denied: you can only mark your own notifications as read")
	}

	if userNotif.Status == models.NotificationStatusRead {
		log.Printf("MarkNotificationAsRead: User notification %s is already marked as read for user %s", id.Hex(), requesterID.Hex())
		return true, nil
	}

	err = r.NotificationService.MarkAsRead(ctx, id)
	if err != nil {
		log.Printf("MarkNotificationAsRead: Failed to mark user notification %s as read for user %s: %v", id.Hex(), requesterID.Hex(), err)
		return false, fmt.Errorf("could not mark notification as read: %w", err)
	}

	log.Printf("MarkNotificationAsRead: Successfully marked user notification %s as read for user %s", id.Hex(), requesterID.Hex())
	
	// === ДОБАВЛЕННЫЙ КОД ДЛЯ ПУБЛИКАЦИИ В REDIS ===
	// После успешного изменения статуса, публикуем сообщение в Redis
	redisChannel := fmt.Sprintf("unread_notifications_changed:%s", requesterID.Hex())
	log.Printf("MarkNotificationAsRead: Attempting to publish to Redis channel: %s", redisChannel) // Добавлен лог
	// Предполагается, что Publish принимает context
	err = r.RedisService.Publish(redisChannel, "updated") 
	if err != nil {
		// Логируем ошибку, но не возвращаем её клиенту, 
		// так как основная операция (mark as read) прошла успешно
		log.Printf("MarkNotificationAsRead: Failed to publish to Redis channel %s: %v", redisChannel, err)
		// Можно решить, стоит ли здесь возвращать ошибку или нет.
		// Обычно ошибки публикации в Redis не критичны для основной бизнес-логики.
		// return false, fmt.Errorf("failed to notify subscribers: %w", err) // Опционально
	} else {
		log.Printf("MarkNotificationAsRead: Successfully published to Redis channel: %s", redisChannel) // Добавлен лог
	}
	// ================================================

	return true, nil
}

// Sender is the resolver for the sender field.
func (r *notificationResolver) Sender(ctx context.Context, obj *models.Notification) (*model.NotificationSender, error) {
	// Получаем отправителя по ID из уведомления
	user, err := r.UserService.GetUserByID(ctx, obj.SenderID)
	if err != nil {
		return nil, fmt.Errorf("failed to get sender user: %w", err)
	}

	// Создаем NotificationSender из данных пользователя
	sender := &model.NotificationSender{
		ID:       user.ID,
		FullName: user.FullName,
		Building: user.Building,
	}

	return sender, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*models.User, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized: valid authentication cookie is required")
	}

	userIDHex := userClaims.UserID
	userObjectID, err := primitive.ObjectIDFromHex(userIDHex)
	if err != nil {
		log.Printf("Me: Invalid ObjectID format in token for UserID: %s", userIDHex)
		return nil, fmt.Errorf("invalid authentication data")
	}

	user, err := r.UserService.GetUserByID(ctx, userObjectID)
	if err != nil {
		log.Printf("Me: Failed to get user data for ID %s: %v", userIDHex, err)
		return nil, fmt.Errorf("user account unavailable")
	}

	return user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized: valid authentication required")
	}

	log.Printf("Users query: Requested by user ID %s", userClaims.UserID)

	requesterObjectID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		log.Printf("Users query: Invalid ObjectID format in token for UserID: %s", userClaims.UserID)
		return nil, fmt.Errorf("invalid authentication data")
	}

	requester, err := r.UserService.GetUserByID(ctx, requesterObjectID)
	if err != nil {
		log.Printf("Users query: Failed to get requester data for ID %s: %v", userClaims.UserID, err)
		return nil, fmt.Errorf("could not retrieve requester information")
	}

	allUsers, err := r.UserService.GetUsers(ctx)
	if err != nil {
		log.Printf("Users query: Failed to retrieve users from service: %v", err)
		return nil, fmt.Errorf("could not retrieve users list: %w", err)
	}

	var filteredUsers []*models.User
	switch requester.Role {
	case models.UserRoleDgis:
		log.Printf("Users query: DGIS user, returning all %d users", len(allUsers))
		filteredUsers = allUsers
	case models.UserRolePredsedatel:
		for _, user := range allUsers {
			if user.Role == models.UserRoleStarosta || user.Role == models.UserRoleSupervisor {
				filteredUsers = append(filteredUsers, user)
			}
		}
		log.Printf("Users query: PREDSEDATEL user, returning %d users (STAROSTA and SUPERVISOR only)", len(filteredUsers))
	default:
		log.Printf("Users query: User with role %s attempted to access users list - this should be blocked by schema directives", requester.Role)
		return nil, fmt.Errorf("access denied: insufficient permissions to view users list")
	}

	for _, user := range filteredUsers {
		user.Password = ""
	}

	log.Printf("Users query: Successfully retrieved and filtered %d users for requester %s", len(filteredUsers), userClaims.UserID)
	return filteredUsers, nil
}

// Dashboard is the resolver for the dashboard field.
func (r *queryResolver) Dashboard(ctx context.Context) ([]*models.Marker, error) {
	log.Println("Dashboard resolver called")

	markers, err := r.MarkerService.GetAllMarkersWithUsers(ctx)
	if err != nil {
		log.Printf("Dashboard: Failed to retrieve all markers with users from DB: %v", err)
		return nil, fmt.Errorf("could not load dashboard data")
	}

	log.Printf("Dashboard: Successfully retrieved %d markers from service", len(markers))

	if len(markers) > 0 {
		firstMarker := markers[0]
		log.Printf("Dashboard: First marker ID: %s, Label: %s", firstMarker.ID.Hex(), firstMarker.Label)
		log.Printf("Dashboard: First marker Users field length: %d", len(firstMarker.Users))
		if len(firstMarker.Users) > 0 {
			firstUser := firstMarker.Users[0]
			if firstUser != nil {
				log.Printf("Dashboard: First marker's first user ID: %s, Name: %s", firstUser.ID.Hex(), firstUser.FullName)
			} else {
				log.Println("Dashboard: WARNING: First marker's first user is NIL")
			}
		} else {
			log.Println("Dashboard: First marker has NO users")
		}
	}

	return markers, nil
}

// MyNotifications is the resolver for the myNotifications field.
func (r *queryResolver) MyNotifications(ctx context.Context, statuses []models.NotificationStatus, limit *int, offset *int) ([]*models.UserNotification, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID in token")
	}

	limitVal := 20
	if limit != nil && *limit > 0 {
		limitVal = *limit
	}
	offsetVal := 0
	if offset != nil && *offset > 0 {
		offsetVal = *offset
	}

	var modelStatuses []models.NotificationStatus
	for _, status := range statuses {
		modelStatuses = append(modelStatuses, models.NotificationStatus(status))
	}

	userNotifs, err := r.NotificationService.GetUserNotifications(ctx, userID, modelStatuses, limitVal, offsetVal)
	if err != nil {
		log.Printf("MyNotifications: Failed to get notifications for user %s: %v", userID.Hex(), err)
		return nil, fmt.Errorf("could not retrieve notifications")
	}

	log.Printf("MyNotifications: Retrieved %d notifications for user %s", len(userNotifs), userID.Hex())
	return userNotifs, nil
}

// UnreadNotificationsCount is the resolver for the unreadNotificationsCount field.
func (r *queryResolver) UnreadNotificationsCount(ctx context.Context) (int, error) {
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		return 0, fmt.Errorf("unauthorized")
	}

	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return 0, fmt.Errorf("invalid user ID in token")
	}

	count, err := r.NotificationService.GetUnreadCount(ctx, userID)
	if err != nil {
		log.Printf("UnreadNotificationsCount: Failed to count for user %s: %v", userID.Hex(), err)
		return 0, fmt.Errorf("could not count notifications")
	}

	return count, nil
}

// UnreadNotificationsCountChanged is the resolver for the unreadNotificationsCountChanged field.
func (r *subscriptionResolver) UnreadNotificationsCountChanged(ctx context.Context) (<-chan int, error) {
	// Извлекаем информацию о пользователе из контекста, установленного AuthMiddleware
	userClaims, isAuthenticated := middleware.GetUserFromContext(ctx)
	if !isAuthenticated {
		// Возвращаем ошибку, если пользователь не аутентифицирован
		// Это остановит подписку на этапе установления соединения
		return nil, fmt.Errorf("unauthorized: valid authentication cookie is required for subscription")
	}

	// Получаем ID пользователя из токена
	userID, err := primitive.ObjectIDFromHex(userClaims.UserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID in authentication token")
	}

	// Создаем канал для отправки обновлений клиенту
	notificationsChannel := make(chan int, 1) // Буферизованный канал для предотвращения блокировки

	// Формируем уникальный ключ канала Redis Pub/Sub для этого пользователя
	redisChannel := fmt.Sprintf("unread_notifications_changed:%s", userID.Hex())
	log.Printf("UnreadNotificationsCountChanged: User %s subscribing to Redis channel: %s", userID.Hex(), redisChannel) // Добавлен лог

	// Подписываемся на Redis канал
	// Предполагается, что r.RedisService имеет метод Subscribe, возвращающий объект,
	// совместимый с go-redis pubsub (например, *redis.PubSub)
	// ВАЖНО: Убедитесь, что ваш метод Subscribe принимает context.Context
	// Передаем context в Subscribe
	pubsub := r.RedisService.Subscribe(redisChannel) 

	// Запускаем горутину для обработки подписки на Redis и отправки данных клиенту
	go func() {
		// defer для корректного закрытия ресурсов при выходе из горутины
		defer close(notificationsChannel)
		defer func() {
			if pubsub != nil {
				pubsub.Close() // Закрываем подписку на Redis при завершении
				log.Printf("UnreadNotificationsCountChanged: Closed Redis subscription for user %s on channel %s", userID.Hex(), redisChannel) // Добавлен лог
			}
		}()

		// Отправляем начальное значение количества непрочитанных уведомлений
		initialCount, err := r.NotificationService.GetUnreadCount(ctx, userID)
		if err != nil {
			log.Printf("UnreadNotificationsCountChanged: Failed to get initial unread count for user %s: %v", userID.Hex(), err)
			// Можно вернуть 0 или просто не отправлять ничего
			// Здесь мы отправим 0, чтобы клиент получил хотя бы один результат
			initialCount = 0
		}

		log.Printf("UnreadNotificationsCountChanged: Sending initial unread count %d to user %s", initialCount, userID.Hex()) // Добавлен лог

		// Пытаемся отправить начальное значение в канал подписки
		// Используем select с ctx.Done() для обработки отмены контекста
		select {
		case notificationsChannel <- initialCount:
			log.Printf("UnreadNotificationsCountChanged: Sent initial unread count %d to user %s", initialCount, userID.Hex())
		case <-ctx.Done():
			// Контекст был отменен (клиент отключился) до отправки начального значения
			log.Printf("UnreadNotificationsCountChanged: Client disconnected before initial count sent for user %s", userID.Hex())
			return
		}

		// Цикл обработки сообщений из Redis
		// Используем pubsub.Channel() для получения канала сообщений
		// Получаем канал сообщений из pubsub
		redisMsgChannel := pubsub.Channel()
		log.Printf("UnreadNotificationsCountChanged: Listening for messages on Redis channel for user %s", userID.Hex()) // Добавлен лог
		for {
			select {
			case <-ctx.Done():
				// Контекст отменен, обычно это означает, что клиент отключился.
				// Выполняем defer и выходим из горутины.
				log.Printf("UnreadNotificationsCountChanged: Context cancelled, unsubscribing user %s from Redis channel %s", userID.Hex(), redisChannel)
				return
			case msg, ok := <-redisMsgChannel: // Получаем сообщение из канала Redis
				if !ok {
					// Канал Redis был закрыт
					log.Printf("UnreadNotificationsCountChanged: Redis message channel closed for user %s", userID.Hex())
					return
				}
				if msg != nil {
					log.Printf("UnreadNotificationsCountChanged: Received message on Redis channel for user %s: Channel=%s, Payload=%s", userID.Hex(), msg.Channel, msg.Payload)
					// При получении сообщения в Redis канале, получаем актуальное количество
					currentCount, err := r.NotificationService.GetUnreadCount(ctx, userID)
					if err != nil {
						log.Printf("UnreadNotificationsCountChanged: Failed to get unread count for user %s after Redis message: %v", userID.Hex(), err)
						// Можно отправить ошибку клиенту или просто продолжить
						// Здесь мы продолжаем, надеясь на следующее сообщение
						continue
					}

					log.Printf("UnreadNotificationsCountChanged: Sending updated unread count %d to user %s", currentCount, userID.Hex()) // Добавлен лог

					// Отправляем обновленное количество клиенту через GraphQL подписку
					select {
					case notificationsChannel <- currentCount:
						log.Printf("UnreadNotificationsCountChanged: Sent updated unread count %d to user %s", currentCount, userID.Hex())
					case <-ctx.Done():
						// Клиент отключился во время отправки
						log.Printf("UnreadNotificationsCountChanged: Client disconnected while sending update to user %s", userID.Hex())
						return
					}
				} else {
					// msg == nil, что может означать закрытие канала или другую проблему
					// Этот случай обрабатывается проверкой `ok` выше.
					log.Printf("UnreadNotificationsCountChanged: Received nil message on Redis channel for user %s", userID.Hex())
				}
			}
		}
	}()

	// Возвращаем канал, из которого GraphQL сервер будет читать данные для клиента
	return notificationsChannel, nil
}

// Markers is the resolver for the markers field.
func (r *userResolver) Markers(ctx context.Context, obj *models.User) ([]*models.Marker, error) {
	if len(obj.Markers) == 0 {
		return []*models.Marker{}, nil
	}

	filter := bson.M{"_id": bson.M{"$in": obj.Markers}}

	markerCollection := r.MarkerService.GetCollection("markers")

	var markers []*models.Marker

	err := query.FindMany(ctx, markerCollection, filter, &markers)
	if err != nil {
		log.Printf("userResolver.Markers: DB error for user %s (%s): %v", obj.Login, obj.ID.Hex(), err)
		return []*models.Marker{}, nil
	}

	return markers, nil
}

// Notification is the resolver for the notification field.
func (r *userNotificationResolver) Notification(ctx context.Context, obj *models.UserNotification) (*models.Notification, error) {
	notification, err := r.NotificationService.GetNotificationByID(ctx, obj.NotificationID)
	if err != nil {
		log.Printf("userNotificationResolver.Notification: Failed to get notification %s: %v", obj.NotificationID.Hex(), err)
		return nil, fmt.Errorf("failed to load notification details: %w", err)
	}
	return notification, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Notification returns NotificationResolver implementation.
func (r *Resolver) Notification() NotificationResolver { return &notificationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

// UserNotification returns UserNotificationResolver implementation.
func (r *Resolver) UserNotification() UserNotificationResolver { return &userNotificationResolver{r} }

type mutationResolver struct{ *Resolver }
type notificationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
type userNotificationResolver struct{ *Resolver }
